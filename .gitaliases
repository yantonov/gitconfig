[alias]
# common
# first commit can not be moved so you need to create empty commit as initial
it = "!git init && git commit -m 'root' --allow-empty"

co = checkout
br = branch -vv
st = status -sb
c = commit
cm = commit -m
ca = commit -a
cam = commit -a -m
com = commit -m
cat = cat-file -p
ps = push
pl = pull
unstage = reset HEAD --

# stash
staash = "stash --include-untracked"

# current branch
cb = "rev-parse --abbrev-ref HEAD"

# kill deleted remote branches
purge-branch = "fetch --prune"
clean-branches = "remote prune"

# merge
merc = "merge --no-ff"

# LOG
# simple one line log
ls = log --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %C(bold blue)<%an>%Creset'
# changed files
ll = log --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %C(bold blue)<%an>%Creset' --decorate --numstat
# no colors
lnc = log --pretty=format:"%h\\ %s\\ [%cn]"
# commits with dates
ldt = log --all --pretty=format:'%Cred%h%Creset %Cgreen%ad%Creset -%C(yellow)%d%Creset %s %C(bold blue)<%an>%Creset'
# commits with short dates
lds = "!git ldt --date=short"
# commits with relative dates
ldr = "!git ldt --date=relative"
# commits with date and times
ldi = "!git ldt --date=iso"
# graph representation
lgraph = log --all --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ci)%Creset %C(bold blue)<%an>%Creset'
# default look for short git log
ldef = log --oneline --decorate
# commits related to a file
filelog = log -u
fl = log -u
# last commit
lc = "!git ll -1"

# DIFF
# Show a diff last commit:
dlc = diff --cached HEAD^
diffc = diff --cached HEAD
# Show content (full diff) of a commit given a revision:
dr    = "!f() { if [ -z "$1" ]; then echo 'revision is not defined'; echo 'usage git dr <revision>'; else git diff "$1"^.."$1"; fi }; f"
diffr = "!f() { if [ -z "$1" ]; then echo 'revision is not defined'; echo 'usage git dr <revision>'; else git diff "$1"^.."$1"; fi }; f"

# GREP/SEARCH
# Search/grep your entire codebase for a string:
gr = grep -Ii
# Grep from root folder:
gra = "!f() { A=$(pwd) && TOPLEVEL=$(git rev-parse --show-toplevel) && cd $TOPLEVEL && git grep --full-name --color -In $1 && cd $A; }; f"
# Find a file path in codebase:
f = "!git ls-files | grep -i"

# ALIAS
# List all your aliases
la = "!git config -l | grep alias | cut -c 7-"

# FIX
# something like hg rollback
rollback = "reset --soft HEAD~"
# remove already committed trash
fuck = "reset --hard HEAD^"

# reset working directory
clearwd = "reset --hard"

# cleanup untracked files
purge = "clean -d -i"
show-purge = "clean -d -n"

# REPOSITORY ROOT
root = "!pwd"

# commit and forgot to add file
commend = "commit --amend --no-edit"

# force
please = "push --force-with-lease"

# TAGS
# show the last tag
lasttag = describe --tags --abbrev=0
lt      = describe --tags --abbrev=0

# MERGE
# Being the Branch/Integration manager at my current client, I use these constantly to merge stuff:
ours = "!f() { git co --ours $@ && git add $@; }; f"
theirs = "!f() { git co --theirs $@ && git add $@; }; f"
